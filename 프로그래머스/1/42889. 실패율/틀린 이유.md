### 실패 했던 기존 코드

```js
function solution(N, stages) {
    
    // 스테이지(x)에 도달한 플레이어 수 = stages의 값이 x 이상인 플레이어의 수
    // 스테이지(x)에 도달했으나 클리어 못한 플레이어 수 = stage의 값이 x인 플레이어 수
  
    stages.sort((a, b) => a - b);
    let count = 0; // stage의 값이 x인 플레이어 수
    
    const failMap = new Map(Array.from({length: N}, (_, idx) => [idx+1, 0]));
    
    for(let i = 0; i < stages.length; i++){
        if(stages[i] > N) break;
        count += 1;
        if(i > 0 && i < stages.length - 1 && stages[i] === stages[i+1]) continue;
        const playerSuccessed = (stages.length - 1) - (i - count);
        failMap.set(stages[i], count / playerSuccessed);
        count = 0;
    }
    
    console.log(failMap)
    
    // 실패율이 높은 것부터 정렬 (내림차순)
    // 실패율이 같을 때는 낮은 스테이지부터 정렬
    const answer = [...failMap.entries()].sort((a, b) => {
        if(a[1] === b[1]) return a[0] - b[0];
        return b[1] - a[1];
    }).map(([stage, _]) => stage);
    
    return answer;
    

}
```

### 이유 및 반례
반례 있어요. 이 케이스에서 오답이 납니다.

* N = 2
* stages = [1, 1, 2, 3]   (3은 N+1, 즉 모든 스테이지 클리어)

정답은 두 스테이지의 실패율이 각각 0.5로 같으니, 번호가 작은 스테이지가 먼저 와서 **[1, 2]**가 되어야 합니다.

그런데 올려준 코드로 돌리면 다음처럼 계산돼요.

* stage 1 실패율을 두 번 나눠 계산해버려서 최종적으로 **1/3 ≈ 0.333…** 이 저장됨
* stage 2 실패율은 **1/2 = 0.5**
* 내림차순 정렬하면 **[2, 1]**이 나옴 → 오답

### 왜 이런 버그가 생기나?

이 줄 때문입니다:

```js
if (i > 0 && stages[i] === stages[i+1]) continue;
```

첫 블록(가장 작은 스테이지 값)에서 `i === 0`일 때는 `continue`가 걸리지 않아 **블록이 끝나기도 전에** 실패율을 한 번 기록하고 `count`를 0으로 리셋합니다. 그래서 첫 스테이지의 개수가 끊겨 누락돼요.
즉, “첫 블록에 중복이 있을 때” 깨지는 패턴입니다.

#### 빠른 수정 방법

`i > 0` 조건을 없애고, 경계 체크만 하면 됩니다.

```js
if (i + 1 < stages.length && stages[i] === stages[i + 1]) continue;
```

또는 아예 더 깔끔하게, **카운팅 배열**로 구현하면 실수할 여지가 줄어듭니다.

```js
function solution(N, stages) {
  const cnt = Array(N + 2).fill(0); // 1..N+1
  for (const s of stages) cnt[s]++;

  const fail = [];
  let players = stages.length; // 해당 스테이지에 도달한 사람 수(점점 줄어듦)

  for (let stage = 1; stage <= N; stage++) {
    const stuck = cnt[stage];
    const rate = players ? stuck / players : 0;
    fail.push([stage, rate]);
    players -= stuck;
  }

  return fail
    .sort((a, b) => (b[1] === a[1] ? a[0] - b[0] : b[1] - a[1]))
    .map(([s]) => s);
}
```
> [!note]
> 요약: 반례는 `N=2, stages=[1,1,2,3]`. 원인은 첫 블록에서 `i > 0` 가드 때문에 중복 누적이 끊기는 것. 위 두 가지 방법 중 하나로 고치면 통과합니다.

## 레슨런
조건이 잘 맞는지 한번 검토하자. 다른 방식으로 조건식을 쓰다가, 전략을 바꿨는데, 이 전의 조건식과 겹쳐서 쓰다 이런 문제가 발생한거 같다.


### 다른 사람 풀이
https://school.programmers.co.kr/learn/courses/30/lessons/42889/solution_groups?language=javascript

```js
function solution(N, stages) {
    let result = [];
    for(let i=1; i<=N; i++){
        let reach = stages.filter((x) => x >= i).length;
        let curr = stages.filter((x) => x === i).length;
        result.push([i, curr/reach]);
    }
    result.sort((a,b) => b[1] - a[1]);
    return result.map((x) => x[0]);
}
```
