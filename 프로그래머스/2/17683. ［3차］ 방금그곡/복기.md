## 다른 사람 풀이
```js
const solution = (m, musicInfos) => {
    let answer = '';

    musicInfos = musicInfos.map(e => {
        let eArr = e.split(',');
        let timeDiff = (new Date(`1970-01-01 ${eArr[1]}:00`) - new Date(`1970-01-01 ${eArr[0]}:00`)) / 60000;
        let melody = eArr[3].replace(/[A-Z]#/g,m => m[0].toLowerCase());
        melody = melody.repeat(Math.ceil(timeDiff / melody.length)).substr(0, timeDiff);
        return `${timeDiff},${eArr[2]},${melody}`;
    });

    musicInfos.sort((a,b) => b.split(',')[0] - a.split(',')[0]);

    answer = musicInfos.filter(e => e.split(',')[2].indexOf(m.replace(/[A-Z]#/g,m => m[0].toLowerCase())) != -1);

    return answer.length == 0 ? '(None)' : answer[0].split(',')[1];
}
```
### 나랑 다른 점
- 시간을 Date로 사용했음
- C#과 같은 케이스를 정규식으로 파싱하지 않고, 소문자(C# -> c)로 바꿔 구분을 둬서, repeat과 같은 반복 및 멜로디 문자열의 일치를 쉽게 함.

## 복기
- 반복이 여러번 되는 케이스를 아래와 같이 함
```js
// 배열의 요소 반복이 한번 이상 될 수 있음
            let repeat = Math.floor(playDuration/totalDuration);
            const left = playDuration % totalDuration;
            let arr = [];
            while(repeat > 0){
                arr = [...arr, ...toneList];
                repeat--;
            }
            totalTones = [...arr, ...toneList.slice(0, left)];
```
- 그냥 join을 해서 비교하면, C, C#구분 못할 수 있음. 배열로 직접 비교
- 예외 케이스 누락해서 실패했었음
```js
if(answer.length === 0) return "(None)";
```
